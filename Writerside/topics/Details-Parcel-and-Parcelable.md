# Details: Parcel and Parcelable

## Pacel 과 Parcelable

### Parcel과 Parcelable의 개념과 역할

`Parcel`과 `Parcelable`은 안드로이드의 고성능 프로세스 간 통신(IPC)을 위해 설계된 핵심 요소이다.

### Parcel: 고성능 IPC를 위한 데이터 컨테이너

`Parcel`은 프로세스 간 통신(IPC) 메커니즘을 통해 전송될 데이터를 담는 컨테이너 클래스이다. 이것의 주된 목적은 데이터를 **마샬링(Marshalling)** 및 **언마샬링(Unmarshalling)**하여 안드로이드의 IPC 경계를 넘어 전달할 수 있도록 하는 것이다.

* **마샬링(Marshalling)**: 객체 또는 데이터를 전송 가능한 형태(일련의 바이트 스트림)로 변환하는 과정. '평탄화'라고도 한다.
* **언마샬링(Unmarshalling)**: 마샬링된 데이터를 다시 원래의 객체 구조로 복원하는 과정.

`Parcel`은 고성능 IPC 전송을 위해 특별히 설계되었으며, 기본 데이터 타입, 배열, 그리고 `Parcelable` 인터페이스를 구현한 객체 등을 담을 수 있다.


### Parcelable: 객체의 직렬화 규약

`Parcelable`은 객체가 스스로의 상태를 `Parcel`에 쓰고, 다시 `Parcel`로부터 복원하는 방법을 정의하는 안드로이드 전용 인터페이스이다.

객체가 `Parcelable` 인터페이스를 구현한다는 것은, 해당 객체가 안드로이드 컴포넌트 간에 효율적으로 전달될 수 있는 '직렬화 규약'을 따름을 의미한다. 이는 자바의 표준 `Serializable` 인터페이스보다 안드로이드 환경에서 훨씬 더 빠른 성능을 보인다.

### 주요 특징 및 제약사항

* **고성능**: `Parcelable`은 리플렉션(reflection)을 사용하지 않으므로, 리플렉션 기반의 `Serializable`보다 월등히 빠르다.
* **최적화**: `Parcelable`을 처리할 때, `Parcel`은 클래스 정보와 같은 메타데이터를 생략하여 처리 효율을 높인다. 이 때문에 데이터를 읽는 쪽에서는 어떤 타입의 객체가 올 것인지 미리 알고 있어야 한다.
* **비영구성**: `Parcel`의 내부 구현은 안드로이드 버전에 따라 변경될 수 있다. 따라서 영구 저장소(DB, 파일 등)에 데이터를 저장하는 용도로 `Parcel`을 사용해서는 안 된다. 오직 임시적인 데이터 전송 용도로만 사용해야 한다.

### 요약

* **Parcel**은 고성능 IPC를 위한 데이터 **컨테이너**이다.
* **Parcelable**은 객체가 `Parcel`에 자신을 쓰고 복원하는 방법을 정의하는 **인터페이스**이다.
* `Parcelable`을 구현한 객체를 `Parcel`에 담아 안드로이드 컴포넌트 간에 데이터를 효율적으로 전달한다.